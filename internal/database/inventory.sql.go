// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addLineItem = `-- name: AddLineItem :one
WITH inserted_line_item AS (
    INSERT INTO inventory (id, created_at, updated_at, quantity, owner_id, item_name)
    VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
    RETURNING id, created_at, updated_at, quantity, owner_id, item_name
)
SELECT inserted_line_item.id, inserted_line_item.created_at, inserted_line_item.updated_at, inserted_line_item.quantity, inserted_line_item.owner_id, inserted_line_item.item_name, players.name AS owner_name
FROM inserted_line_item
INNER JOIN players
ON inserted_line_item.owner_id = players.id
INNER JOIN items
ON inserted_line_item.item_name = items.name
`

type AddLineItemParams struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Quantity  int32
	OwnerID   uuid.UUID
	ItemName  string
}

type AddLineItemRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Quantity  int32
	OwnerID   uuid.UUID
	ItemName  string
	OwnerName string
}

func (q *Queries) AddLineItem(ctx context.Context, arg AddLineItemParams) (AddLineItemRow, error) {
	row := q.db.QueryRowContext(ctx, addLineItem,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Quantity,
		arg.OwnerID,
		arg.ItemName,
	)
	var i AddLineItemRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Quantity,
		&i.OwnerID,
		&i.ItemName,
		&i.OwnerName,
	)
	return i, err
}

const getItemsByOwner = `-- name: GetItemsByOwner :many
SELECT items.name, items.created_at, items.updated_at, items.description, items.category, inventory.quantity AS quantity
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id = $1
`

type GetItemsByOwnerRow struct {
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Description sql.NullString
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetItemsByOwner(ctx context.Context, ownerID uuid.UUID) ([]GetItemsByOwnerRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByOwnerRow
	for rows.Next() {
		var i GetItemsByOwnerRow
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByOwnerAndCat = `-- name: GetItemsByOwnerAndCat :many
SELECT items.name, items.created_at, items.updated_at, items.description, items.category, inventory.quantity AS quantity
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id = $1 AND items.category = $2
`

type GetItemsByOwnerAndCatParams struct {
	OwnerID  uuid.UUID
	Category sql.NullString
}

type GetItemsByOwnerAndCatRow struct {
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Description sql.NullString
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetItemsByOwnerAndCat(ctx context.Context, arg GetItemsByOwnerAndCatParams) ([]GetItemsByOwnerAndCatRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByOwnerAndCat, arg.OwnerID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByOwnerAndCatRow
	for rows.Next() {
		var i GetItemsByOwnerAndCatRow
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByOwnerName = `-- name: GetItemsByOwnerName :many
SELECT items.name, items.created_at, items.updated_at, items.description, items.category, inventory.quantity AS quantity
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id IN (
    SELECT players.id
    FROM players
    WHERE players.name = $1 AND players.game_id IN (
        SELECT games.id
        FROM games
        WHERE games.name = $2 AND games.server_id = $3
    )
)
`

type GetItemsByOwnerNameParams struct {
	Name     string
	Name_2   string
	ServerID string
}

type GetItemsByOwnerNameRow struct {
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Description sql.NullString
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetItemsByOwnerName(ctx context.Context, arg GetItemsByOwnerNameParams) ([]GetItemsByOwnerNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByOwnerName, arg.Name, arg.Name_2, arg.ServerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByOwnerNameRow
	for rows.Next() {
		var i GetItemsByOwnerNameRow
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByOwnerNameAndCat = `-- name: GetItemsByOwnerNameAndCat :many
SELECT items.name, items.created_at, items.updated_at, items.description, items.category, inventory.quantity AS quantity
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id IN (
    SELECT players.id
    FROM players
    WHERE players.name = $1 AND players.game_id IN (
        SELECT games.id
        FROM games
        WHERE games.name = $2 AND games.server_id = $3
    )
) AND items.category = $4
`

type GetItemsByOwnerNameAndCatParams struct {
	Name     string
	Name_2   string
	ServerID string
	Category sql.NullString
}

type GetItemsByOwnerNameAndCatRow struct {
	Name        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Description sql.NullString
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetItemsByOwnerNameAndCat(ctx context.Context, arg GetItemsByOwnerNameAndCatParams) ([]GetItemsByOwnerNameAndCatRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsByOwnerNameAndCat,
		arg.Name,
		arg.Name_2,
		arg.ServerID,
		arg.Category,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByOwnerNameAndCatRow
	for rows.Next() {
		var i GetItemsByOwnerNameAndCatRow
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLineItemByItemAndOwner = `-- name: GetLineItemByItemAndOwner :one
SELECT inventory.id, inventory.created_at, inventory.updated_at, inventory.quantity, inventory.owner_id, inventory.item_name
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id = $1 AND inventory.item_name = $2
`

type GetLineItemByItemAndOwnerParams struct {
	OwnerID  uuid.UUID
	ItemName string
}

func (q *Queries) GetLineItemByItemAndOwner(ctx context.Context, arg GetLineItemByItemAndOwnerParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getLineItemByItemAndOwner, arg.OwnerID, arg.ItemName)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Quantity,
		&i.OwnerID,
		&i.ItemName,
	)
	return i, err
}

const getLineItemByItemAndOwnerName = `-- name: GetLineItemByItemAndOwnerName :one
SELECT inventory.id, inventory.created_at, inventory.updated_at, inventory.quantity, inventory.owner_id, inventory.item_name
FROM inventory
INNER JOIN players
ON inventory.owner_id = players.id
INNER JOIN items
ON inventory.item_name = items.name
WHERE inventory.owner_id IN (
    SELECT players.id
    FROM players
    WHERE players.name = $1 AND players.game_id IN (
        SELECT games.id
        FROM games
        WHERE games.name = $2 AND games.server_id = $3
    )
) AND inventory.item_name = $4
`

type GetLineItemByItemAndOwnerNameParams struct {
	Name     string
	Name_2   string
	ServerID string
	ItemName string
}

func (q *Queries) GetLineItemByItemAndOwnerName(ctx context.Context, arg GetLineItemByItemAndOwnerNameParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, getLineItemByItemAndOwnerName,
		arg.Name,
		arg.Name_2,
		arg.ServerID,
		arg.ItemName,
	)
	var i Inventory
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Quantity,
		&i.OwnerID,
		&i.ItemName,
	)
	return i, err
}

const updateLineItemWID = `-- name: UpdateLineItemWID :exec
UPDATE inventory
SET quantity = quantity + $1, updated_at = $2
WHERE owner_id = $3 AND item_name = $4
`

type UpdateLineItemWIDParams struct {
	Quantity  int32
	UpdatedAt time.Time
	OwnerID   uuid.UUID
	ItemName  string
}

func (q *Queries) UpdateLineItemWID(ctx context.Context, arg UpdateLineItemWIDParams) error {
	_, err := q.db.ExecContext(ctx, updateLineItemWID,
		arg.Quantity,
		arg.UpdatedAt,
		arg.OwnerID,
		arg.ItemName,
	)
	return err
}

const updateLineItemWName = `-- name: UpdateLineItemWName :exec
UPDATE inventory
SET quantity = quantity + $1, updated_at = $2
WHERE owner_id IN (
    SELECT players.id
    FROM players
    WHERE players.name = $3 AND players.game_id IN (
        SELECT games.id
        FROM games
        WHERE games.name = $4 AND games.server_id = $5
    )
) AND item_name = $6
`

type UpdateLineItemWNameParams struct {
	Quantity  int32
	UpdatedAt time.Time
	Name      string
	Name_2    string
	ServerID  string
	ItemName  string
}

func (q *Queries) UpdateLineItemWName(ctx context.Context, arg UpdateLineItemWNameParams) error {
	_, err := q.db.ExecContext(ctx, updateLineItemWName,
		arg.Quantity,
		arg.UpdatedAt,
		arg.Name,
		arg.Name_2,
		arg.ServerID,
		arg.ItemName,
	)
	return err
}
